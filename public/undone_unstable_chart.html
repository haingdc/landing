<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preload" as="image" href="/img/fallback.jpeg" type="image/jpeg" fetchpriority="high" />
  <script type="importmap">
    {
      "imports": {
        "temporal-polyfill": "https://esm.sh/temporal-polyfill@0.3.0?pin=v1&dev",
        "d3": "https://cdn.jsdelivr.net/npm/d3@7/+esm"
      }
    }
  </script>
  <title>Landing</title>
  <style>
    html {
      /* inline background noise. No network request & failure & white flash at page load */
      background-image: url(data:image/png;base64,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);
      background-color: rgb(1 5 19);
      font-family: arial, sans-serif;
    }

    body {
      overflow-x: hidden;
      /* 1D mode places images horizontally and exceeds viewport width */
      margin: 0;
      --round: 8px;
      --round-color: hsl(0, 0%, 80%);
    }

    #root {
      max-width: 1200px;
      margin: auto;
      display: grid;
      grid-template-columns: auto 1fr;
      grid-column-gap: 24px;
      grid-row-gap: 28px;
    }

    .section-header {
      font-size: 32px;
      line-height: 1.6;
      color: hsl(0, 0%, 92%);
      text-transform: uppercase;
    }

    .current-week-container {
      /* grid-column: 1 / 2; */
      position: absolute;

      .content {
        border: 1px solid var(--round-color);
        border-radius: var(--round);
      }

    }

    .weekly-progress-container {
      grid-row: 2 / 3;
      grid-column: 1 / 3;

      .content {
        border: 1px solid var(--round-color);
        border-radius: var(--round);
        overflow: hidden;
      }
    }

    .weekly-progress-table {
      --background-color: hsl(356.8, 100%, 78%);
      border-collapse: collapse;
      border-spacing: 0;
      font-family: arial, sans-serif;
      table-layout: fixed;
      width: 100%;
      border-color: inherit;
      border-collapse: collapse;
      color: hsl(359.7, 74.3%, 52.7%);

      tr {
        border-bottom: 1px solid #6b1211;
      }

      thead tr {
        background-color: var(--background-color);
        border-top-left-radius: var(--round);
        border-top-right-radius: var(--round);
      }

      th {
        padding: 12px 8px;
        text-align: left;
        font-size: 16px;
      }

      td {
        padding: 12px 8px;
      }

      tbody tr:nth-child(even) {
        background-color: var(--background-color);
      }

      tbody tr:nth-child(odd) {
        background-color: hsl(194.7, 93.1%, 60.4%);
        color: hsl(204.9, 98.1%, 41.4%);
      }

      tbody tr:last-child {
          border-bottom-left-radius: var(--round);
          border-bottom-right-radius: var(--round);
      }      
    }
  </style>
  <link rel="shortcut icon" type="image/svg+xml" href="/favicon.ico" />
  <link rel="stylesheet" href="/style.css" />
</head>

<body>
  
  <script type="module">
    /// <reference lib="dom" />
    import * as d3 from "d3";
    import { Temporal } from 'temporal-polyfill'
    import getColor from './scripts/getColor.js'
    import { unstable_delaySpin } from './scripts/unstable_spinDelay.js'
    import { delay } from './scripts/delay.js'
    import { formatDateRange } from './scripts/unstable_formatDateRanges.js'
    import { perceptualToSpring } from './scripts/unstable_spring.js'
    import { currentWeekChart } from './scripts/unstable_currentWeek.js'
    'use strict'

    // === generic scheduler & its debugger
    let scheduledRender = false
    function scheduleRender() {
      if (scheduledRender) return;
      scheduledRender = true
      requestAnimationFrame(function renderAndMaybeScheduleAnotherRender(now) { // eye-grabbing name. No "(anonymous)" function in the debugger & profiler
        scheduledRender = false
        if (render(now)) scheduleRender()
      })
    }

    // === Constants
    const targetWordsDaily = 300
    const listType = 'week'
    const weekdays = [
      "Thứ hai", "Thứ ba", "Thứ tư",
      "Thứ năm", "Thứ sáu", "Thứ bảy", "Chủ nhật"
    ];
    const propKeys = ['tuan', 'soLuongTu', 'avgNgay', 'soNgayViet']
    const columnWidths = ['40%', '20%', '20%', '20%']

    const headers = [
      {
        title: 'Tuần', key: 'tuan', width: '40%'
      },
      {
        title: 'Số lượng từ', key: 'soLuongTu', width: '20%'
      },
      {
        title: 'Avg/ngày', key: 'avgNgay', width: '20%'
      },
      {
        title: 'Số lượng ngày viết trong tuần', key: 'soNgayViet', width: '20%'
      }
    ]

    // === generic spring physics
    // 4ms/step for the spring animation's step. Typically 4 steps for 60fps (16.6ms/frame) and 2 for 120fps (8.3ms/frame). Frame time delta varies, so not always true
    // could use 8ms instead, but 120fps' 8.3ms/frame means the computation might not fit in the remaining 0.3ms, which means sometime the simulation step wouldn't even run once, giving the illusion of jank
    const msPerAnimationStep = 4
    function spring(pos, v = 0, k = 290, b = 30) {
      return {pos, dest: pos, v, k, b} // k = stiffness, b = damping. Try https://chenglou.me/react-motion/demos/demo5-spring-parameters-chooser/
    }
    function springStep(config) {
      // https://blog.maximeheckel.com/posts/the-physics-behind-spring-animations/
      // this seems inspired by https://github.com/chenglou/react-motion/blob/9e3ce95bacaa9a1b259f969870a21c727232cc68/src/stepper.js
      const t = msPerAnimationStep / 1000 // convert to seconds for the physics equation
      const {pos, dest, v, k, b} = config
      // for animations, dest is actually spring at rest. Current position is the spring's stretched/compressed state
      const Fspring = -k * (pos - dest) // Spring stiffness, in kg / s^2
      const Fdamper = -b * v // Damping, in kg / s
      const a = Fspring + Fdamper // a needs to be divided by mass, but we'll assume mass of 1. Adjust k and b to change spring curve instead
      const newV = v + a * t
      const newPos = pos + newV * t

      config.pos = newPos; config.v = newV
    }
    function springGoToEnd(config) {
      config.pos = config.dest
      config.v = 0
    }

    // === generic helpers
    function clamp(min, v, max) {
      return v > max ? max : v < min ? min : v
    }

    // === constant layout metrics.
    const titleSizeY = 52
    const sectionGapY = 28
    const boxesGapX = 24, boxesGapY = 24
    const windowPaddingTop = 40
    const gapTopPeek = 40 // used when programmatically scrolling and wanting to show some gap at the top of a row

    function colsBoxMaxSizeXF(containerSizeX) {
      const boxMinSizeX = 700 // Make sure that on mobile, this min width is big enough not to show 2 images per row. Also, this won't be respected if view's tiny
      const cols = clamp(1, Math.floor((containerSizeX - boxesGapX) / (boxMinSizeX + boxesGapX)), 1) // half of boxesGapX for container's left and right gap
      const boxMaxSizeX = (containerSizeX - boxesGapX - cols * boxesGapX) / cols
      return {cols, boxMaxSizeX}
    }
    
    const isSafari = navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome') // Chrome also includes Safari in user-agent string
    if (isSafari) {
      // alright *deep breath* Desktop Safari is fine, but iPad Safari behaves badly when items exceed the viewport in 1D mode (overflow hidden doesn't work!). This is prominent if you hold arrow right and check the GitHub logo move. It's especially pathological on Stage Manager and any other iPad Safari mode where the app window shrinks and bugs the browser more for whatever reason
      // so we use contain: layout plus viewport width and height to force the clipping of items. Now every browser behaves well with these, BUT Chrome doesn't have rubberbanding of inner elements (only page-wide one). So YES I'm switching to scrolling page instead of document body for Chrome JUST FOR THE RUBBER BANDING on macOS.
      // this is how much I care about edge scroll rubber banding. Thanks Bas Ording & old Apple. If browser specs folks were more visual & interactions-driven as opposed to being static document-driven then we wouldn't have a decade-long decline of visual & interaction design as a discipline.
      // it's a good thing these hacks are easy to pull off under this architecture, and quite readable and even robust despite changing whole container logics
      document.body.style.contain = 'layout'
      document.body.style.width = '100vw'
      document.body.style.height = '100vh'
    }

    // === state
    const debug = false // toggle this for manually stepping through animation frames (press key A)
    const occlusionCulling = false // toggle this to disable occlusion culling (for debugging)
    let debugTimestamp = 0
    let animatedUntilTime = null
    let reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)')
    let anchor = 0 // keep a box stable during resize layout shifts
    let windowSizeX = document.documentElement.clientWidth
    let scrollY = isSafari ? document.body.scrollTo : window.scrollY
    let pointer = {x: -Infinity,y: -Infinity} // btw, on page load, there's no way to render a first cursor state =(
    let events = {keydown: null, click: null, mousemove: null}
    let data; {
      data = [
//      {id: '1', w: 768, h: 1024, $$type: 'spinner'},
//      {id: '0', w:700, h: 400, title: "Thành tích tuần này ", $$type: 'element'}
      ].map((d, i) => {
        const windowSizeY = document.documentElement.clientHeight
        const ar = d.w / d.h
        if (d.$$type === 'element') {
          const sizeX = d.w
          const sizeY = sizeX / ar + titleSizeY
          let node = document.createElement('div')
              node.className = "current-week-container"
          let header = document.createElement('header')
              header.textContent = d.title
          let contentNode = document.createElementNS("http://www.w3.org/2000/svg", "svg")
              contentNode.setAttribute('width', String(d.w))
              contentNode.setAttribute('height', String(d.h))
          node.append(header, contentNode)
          return {
            $$type: d.$$type,
            id: d.id,
            ar, // aspect ratio
            naturalSizeX: d.w,
            sizeX: spring(sizeX),
            sizeY: spring(sizeY),
            x: spring(-windowSizeX),
            y: spring(windowSizeY),
            scale: spring(1),
            fxFactor: spring(20), // for brightness and blur
            node,
          }
        } else if (d.$$type === 'spinner') {
          const sizeX = Math.min(d.w, 300)
          const sizeY = sizeX / ar
          let node = document.createElement('img')
              node.setAttribute('width', String(sizeX))
              node.setAttribute('height', String(sizeY))
              node.src = '/img/fallback.jpeg'
          return {
            $$type: d.$$type,
            id: d.id,
            ar, // aspect ratio
            naturalSizeX: d.w,
            sizeX: spring(sizeX),
            sizeY: spring(sizeY),
            x: spring((windowSizeX - sizeX) / 2),
            y: spring((windowSizeY - sizeY) / 2),
            scale: spring(0.2), // a little bit smaller at first
            fxFactor: spring(20), // for brightness and blur
            node,
          }
        }
        throw new Error('unsupported $$type')
        
      })
    }
    globalThis.data = data;
    function springForEach(f) { // no spring ownership struggle between the spring library above vs consumer; un-inversion of control!
      for (let d of data) {
//      f(d.sizeX); f(d.sizeY); f(d.x); f(d.y); f(d.scale); f(d.fxFactor) // no different than [a, b, c].forEach(f)
        f(d.sizeX, { d, prop: 'sizeX' }); f(d.sizeY, { d, prop: 'sizeY' }); f(d.x, { d, prop: 'x' }); f(d.y, { d, prop: 'y' }); f(d.scale, { d, prop: 'scale' }); f(d.fxFactor, { d, prop: 'fxFactor' }); // no different than [a, b, c].forEach(f)
      }
    }

    // === events
    // pointermove doesn't work on android, pointerdown isn't fired on Safari on the first left click after dismissing context menus, mousedown doesn't trigger properly on mobile, pointerup isn't triggered when pointer panned (at least on iOS), don't forget contextmenu event. Tldr there's no pointer event that works cross-browser that can replace mouse & touch events.
    window.addEventListener('resize', () => scheduleRender())
    window.addEventListener('scroll', () => scheduleRender(), true) // capture is needed for iPad Safari...
    window.addEventListener('popstate', () => scheduleRender())
    window.addEventListener('keydown', (e) => {events.keydown = e; scheduleRender()})
    window.addEventListener('click', (e) => {events.click = e; scheduleRender()})
    window.addEventListener('mousemove', (e) => {events.mousemove = e; scheduleRender()})

    // === static DOM initialization. Just 1 in this app. The more you have here the more your app looks like a PDF document. Minimize
    let dummyPlaceholder = document.createElement('div')
    dummyPlaceholder.style.position = 'absolute'
    dummyPlaceholder.style.width = '1px' // make it tiny in case it affects compositing... sigh lamport.azurewebsites.net/pubs/future-of-computing.pdf
    document.body.append(dummyPlaceholder)
    if (debug) {
      document.documentElement.style.background = 'repeating-linear-gradient(#e66465 0px, #9198e5 300px)'
      document.documentElement.style.height = '100%'
    }

    // === hit testing logic. Boxes' hit area should be static and not follow their current animated state usually (but we can do either)
    function hitTest2DMode(data, pointerX, pointerY) {
      for (let i = 0; i < data.length; i++) {
        let {x, y, sizeX, sizeY} = data[i]
        if (x.dest <= pointerX && pointerX < x.dest + sizeX.dest && y.dest <= pointerY && pointerY < y.dest + sizeY.dest) return i // pointer on this box
      }
      return null
    }

    function render(now) {
      // === step 0: process events
      // keydown
      const inputCode = events.keydown == null ? null : events.keydown.code

      // click
      let clickedTarget = null
      if (events.click != null) {
        //needed to update coords even when we already track
        //mousemove E.g. in Chrome, right click context menu,
        //move elsewhere, then click dismiss. BAM, mousemove triggers
        //with stale/wrong (??) coordinates... Click again without
        //moving, and now you're clicking on the wrong thing
        clickedTarget = events.click.target
        pointer.x = events.click.clientX, pointer.y = events.click.clientY
      }

      //mouse move
      if (events.mousemove != null) {
        //we only use clientX/Y, not pageX/Y, because we want to ignore
        // scrolling. See comment around isSafari above; we either
        //scroll body or window depending on the browser, so pageX/Y might
        //be meaningless (if Safari)
        pointer.x = events.mousemove.clientX
        pointer.y = events.mousemove.clientY
        // btw, pointer can exceed document bounds, e.g. dragging
        // reports back out-of-bound, legal negative values
      }

      if (debug) {
        if (inputCode === 'KeyA') debugTimestamp += 1000/60
        now = debugTimestamp
      }
      // === step1: Batched DOM reads (to avoid accidental DOM read & write interleaving)
      const newWindowSizeX = document.documentElement.clientWidth // exclude scroll bar & invariant under safari pinch zoom
      const windowSizeY = document.documentElement.clientHeight // same
      // this way, when pinch zooming in, we don't occlude away rows
      // outside of the view; if we did, when we zoom out again we wouldn't
      // see those occluded rows until we release our fingers. During
      // safari pinch, no event is triggered so we couldn't have
      // updated the occlusion in real time.
      const animationDisabled = reducedMotion.matches
      const currentScrollY = isSafari ? document.body.scrollTop : window.scrollY
      const currentScrollX = isSafari ? document.body.scrollLeft : window.scrollX
      let focused = null // Rats! It always null in our try
      // Don't forget top & bottom safari UI chrome sizes when vertically
      // occluding, since they're  translucent so we can't over-occlude
      // by ignoring them
      const pointerXLocal = pointer.x +/*toLocal */currentScrollX,
            pointerYLocal = pointer.y +/*toLocal */currentScrollY

      // === step 2: handle inputs-related stage change
      let newFocused = focused
      // === step 3: calculate new layout & cursor
      const { cols , boxMaxSizeX} = colsBoxMaxSizeXF(newWindowSizeX)
      let boxes2DSizeX = [],
          boxes2DSizeY = [],
          rowsTop = [windowPaddingTop] // length : number of rows + 1
      globalThis.rowsTop = rowsTop // for debugging
      { // first pass over data to set final in 2D dimentions and row
        // height
        let rowMaxSizeY = 0
        for (let i = 0; i < data.length; i++) {
          let d = data[i]
          if (d.$$type === 'spinner') {
            const sizeX = Math.min(d.naturalSizeX, boxMaxSizeX, 300)
            const sizeY = sizeX / d.ar
            boxes2DSizeX.push(sizeX)
            boxes2DSizeY.push(sizeY)
            rowMaxSizeY = Math.max(rowMaxSizeY, sizeY)
            if ( i % cols === cols - 1 || i === data.length - 1) { // last 
            // box of row or last box ever
              rowsTop.push(rowsTop.at(-1) + rowMaxSizeY + boxesGapY)
              rowMaxSizeY = 0
            }
          } else if (d.$$type === 'current-week-container') {
            const sizeX = Math.min(d.naturalSizeX, boxMaxSizeX)
            const sizeY = sizeX / d.ar + titleSizeY
            boxes2DSizeX.push(sizeX)
            boxes2DSizeY.push(sizeY)
            rowMaxSizeY = Math.max(rowMaxSizeY, sizeY)
            if ( i % cols === cols - 1 || i === data.length - 1) { // last 
            // box of row or last box ever
              rowsTop.push(rowsTop.at(-1) + rowMaxSizeY + boxesGapY)
              rowMaxSizeY = 0
            }
          } else if (d.$$type === 'weekly-progress-row') {
            const sizeX =  (boxMaxSizeX + boxesGapX) * cols - boxesGapX // full width
            const sizeY = 45
            boxes2DSizeX.push(sizeX)
            boxes2DSizeY.push(sizeY)
            rowMaxSizeY = Math.max(rowMaxSizeY, sizeY)
            if ( i % cols === cols - 1 || i === data.length - 1) { // last 
            // box of row or last box ever
              rowsTop.push(rowsTop.at(-1) + rowMaxSizeY /*+ boxesGapY*/) // no gap between rows in table
              rowMaxSizeY = 0
            }
          } else if (d.$$type === 'weekly-progress-row-header') {
            const sizeX =  (boxMaxSizeX + boxesGapX) * cols - boxesGapX // full width
            const sizeY = 45
            boxes2DSizeX.push(sizeX)
            boxes2DSizeY.push(sizeY)
            rowMaxSizeY = Math.max(rowMaxSizeY, sizeY)
            if ( i % cols === cols - 1 || i === data.length - 1) { // last 
            // box of row or last box ever
              rowsTop.push(rowsTop.at(-1) + rowMaxSizeY /*+ boxesGapY*/) // no gap between rows in table
              rowMaxSizeY = 0
            }
          } else {
            throw new Error("upsupported $$type: ", d.$$type)
          }
          if (i === data.length - 1) {
            rowsTop.push(rowsTop.at(-1) + windowPaddingTop)
          }
        }
      }

      let cursor
      let newAnchor = anchor
      let adjustedScrollTop = currentScrollY
      const hoverMagnetFactor = 40
      if (newFocused == null) { // 2D mode. In fact, no 1D mode exist. We're always be in 2D
        for (let i = 0; i < data.length; i++) { // calculate boxes positions
          let d = data[i]
          if (d.$$type === 'spinner') {
            const sizeX = boxes2DSizeX[i], sizeY = boxes2DSizeY[i]
            const currentRow = Math.floor(i / cols)
            const rowMaxSizeY = rowsTop[currentRow + 1] - boxesGapY - rowsTop[currentRow] // this is res-
            // toring the rowMaxSizeY info above, kinda weird
            d.sizeX.dest = sizeX
            d.sizeY.dest = sizeY
            d.x.dest = (windowSizeX - sizeX) / 2
            d.y.dest = rowsTop[currentRow] + (rowMaxSizeY - sizeY) / 2
            d.y.dest = (windowSizeY - sizeY) / 2 // center vertically
//          d.scale.dest = 1
            d.scale.dest = d.$$timeline === 'forward' ? 1 : 0.2
            d.fxFactor.dest = d.$$timeline === 'forward' ? 1 : 2
//          d.fxFactor.dest = 1
          } else if (d.$$type === 'current-week-container') {
            const sizeX = boxes2DSizeX[i], sizeY = boxes2DSizeY[i]
            const currentRow = Math.floor(i / cols)
            const rowMaxSizeY = rowsTop[currentRow + 1] - boxesGapY - rowsTop[currentRow] // this is res-
            // toring the rowMaxSizeY info above, kinda weird
            d.sizeX.dest = sizeX
            d.sizeY.dest = sizeY
            // Not like the original of Chenglou's Gallery, We align center center but instead top left
            d.x.dest = boxesGapY + (boxMaxSizeX + boxesGapX) * (i % cols) /* + (boxMaxSizeX - sizeX) / 2 // center horizontally */
            d.y.dest = rowsTop[currentRow] /* + (rowMaxSizeY - sizeY) / 2 */
            d.scale.dest = 1
            d.fxFactor.dest = 1
          }  else if (d.$$type === 'weekly-progress-row') {
            const sizeX = boxes2DSizeX[i], sizeY  = boxes2DSizeY[i]
            const currentRow = Math.floor(i / cols)
            const rowMaxSizeY = rowsTop[currentRow + 1] - boxesGapY - rowsTop[currentRow] // this is restoring
            // the rowMaxSizeY info above, kind weird
            d.sizeX.dest = sizeX
            d.sizeY.dest = sizeY
            // Not like the original of Chenglou's Gallery, We align center center but instead top left
            d.x.dest = boxesGapY + (boxMaxSizeX + boxesGapX) * (i % cols) /* + (boxMaxSizeX - sizeX) / 2 // center horizontally */
            d.y.dest = rowsTop[currentRow] /* + (rowMaxSizeY - sizeY) / 2 */
            d.scale.dest = 1
            d.fxFactor.dest = 1
          } else if (d.$$type === 'weekly-progress-row-header') {
            const sizeX = boxes2DSizeX[i], sizeY  = boxes2DSizeY[i]
            const currentRow = Math.floor(i / cols)
            const rowMaxSizeY = rowsTop[currentRow + 1] - boxesGapY - rowsTop[currentRow] // this is restoring
            // the rowMaxSizeY info above, kind weird
            d.sizeX.dest = sizeX
            d.sizeY.dest = sizeY
            // Not like the original of Chenglou's Gallery, We align center center but instead top left
            d.x.dest = boxesGapY + (boxMaxSizeX + boxesGapX) * (i % cols) /* + (boxMaxSizeX - sizeX) / 2 // center horizontally */
            d.y.dest = rowsTop[currentRow] /* + (rowMaxSizeY - sizeY) / 2 */
            d.scale.dest = 1
            d.fxFactor.dest = 1
          } else {
            throw new Error('unsupported $$type')
          }
          
        }

        const hit = hitTest2DMode(data, pointerXLocal, pointerYLocal)
        if (hit == null) cursor = 'auto'
        else { //hovering over a box. Adjust position
/*        cursor = 'zoom-in'
          let {x, y, sizeX, sizeY, scale} = data[hit]
          x.dest += (pointerXLocal - (x.dest + sizeX.dest / 2)) / hoverMagnetFactor
          y.dest += (pointerYLocal - (y.dest + sizeY.dest / 2)) / hoverMagnetFactor
          scale.dest = 1.02
*/
        }

        // If layout shifted, keep the boxes near the same place
        // to prevent annoying layout jumps while viewing
        const anchorY = data.length 
          ? data[anchor].y.dest - gapTopPeek
          : 0
        if (newWindowSizeX !== windowSizeX)
          adjustedScrollTop = Math.max(0, anchorY) // resize ; maintain position!

        if (adjustedScrollTop !== scrollY &&
          Math.abs(anchorY - /*toLocal*/ adjustedScrollTop)
          > windowSizeY / 10) { // find new anchor if the current one moved too much
            for (newAnchor =0 ; newAnchor < data.length; newAnchor += cols) { // new anchor
              // is picked from leftmost column. Btw, old anchor
              // might not be from leftmost col due to resize layout shift
              let d = data[newAnchor]
              // find 1st box whose bottom exceeds 20% of window height
              if (d.y.dest + d.sizeY.dest - /*toLocal*/ adjustedScrollTop > windowSizeY / 5) break 
            }
          }
      } else { // 1D mode. No. It's not exist in our page
      }
      // Ensure that no matter how the scrolling is abruptly
      // adjusted, the boxes on the screen don't suddently jump
      // too. When going 1D -> 2D mode where the dismissed
      // image might be far from the initial one, or when
      // resizing causes layout shifts, the boxes now stay unaffected
      for (let {y} of data) y.post += adjustedScrollTop - currentScrollY


      // === step 4: run animation
      let newAnimatedUntilTime = animatedUntilTime ?? now
      const steps = Math.floor((now - newAnimatedUntilTime) / msPerAnimationStep) // run X spring steps. Decouple physics
      // simulation from framerate!

      newAnimatedUntilTime += steps * msPerAnimationStep
      let stillAnimating = false
      if (animationDisabled) springForEach(springGoToEnd)
      else {
        springForEach((s, { d, prop }) => {
          for(let i = 0; i < steps; i++) springStep(s)
          if (Math.abs(s.v) < 0.01 && Math.abs(s.dest - s.pos) < 0.01 && d.$$type === 'spinner' && prop === 'scale') {
            d.$$timeline = d.$$timeline === 'forward' ? 'reverse' : 'forward'
            stillAnimating = true
          } else
          if (Math.abs(s.v) < 0.01 && Math.abs(s.dest - s.pos) < 0.01) springGoToEnd(s) // close enough done
          else stillAnimating = true
        })
      }
      globalThis.stillAnimating = stillAnimating // for debugging

      // === step 5: render. Batch DOM writes
      const browserUIMaxSizeTop = 100, browserUIMaxSizeBottom
        = 150 // browsers UI like Safari are translucent. Random conservative numbers
      for (let i=0; i < data.length; i++) {
        let d = data[i]
        if (d.$$type === 'weekly-progress-row') { // for table rows with $$type = 'weekly-prgress-row'
          let {node, rootNode} = d
          if ( // occlusion culling, aka only draw what's visible on screen
            // (aka "virtualization")
            !occlusionCulling ||
            d.y.pos - /*toGlobal*/adjustedScrollTop <= windowSizeY + browserUIMaxSizeBottom &&
            d.y.pos + d.sizeY.pos - /*toGlobal*/ adjustedScrollTop >= -browserUIMaxSizeTop &&
            d.x.pos <= newWindowSizeX &&
            d.x.pos + d.sizeX.pos >= 0) { // disregard shadow & sca-
              // ling for you; browserUIMaxSizeBottom and browserUIMaxSize-
              // Top are safe bigger values anyway
              node.style.width = `${d.sizeX.pos}px`
              node.style.height = `${d.sizeY.pos}px`
              node.style.transform = `translate3d(${d.x.pos}px, ${d.y.pos}px, 0) scale(${d.scale.pos})` // safari now
              // anti-aliases for hover, but then zoom in in janks on displays...
              // we can't afford fxFactor & blur for all pics;
              // too expensive for Safari & Chrome. E.g. when zoom-
              // -ing out of a photo, keep scrolling; Chrome stops
              // render on Studio Display
              node.style.filter = newFocused != null && i === newFocused - 1
                || i === newFocused || i === newFocused + 1
                ? `brightness(${d.fxFactor.pos * 100}%)
                  blur(${Math.max(0.6 - d.fxFactor.pos * 6)}px)` // blur these 3 only
                : `brightness(${d.fxFactor.pos * 100}%)` // blur of unrel-
                // ated pics is too fast during transition from/to 1D
                // mode to be seen anyway
              if (debug) node.style.outline = i === newAnchor
                ? '2px solid rgba(255, 255, 0, 0.8)' : 'none'
              if (i === newFocused) {} else {} // let it empty
              if (node.parentNode == null) {
                rootNode.children[1].appendChild(node) // if previous absent , add
                if (rootNode.parentNode == null) {
                  document.body.appendChild(rootNode)
                }
              }
          } else if(node.parentNode != null){
            node.parentNode.removeChild(node) // if previously present , remove
            if (rootNode.children[1].length === 0 && rootNode.parentNode != null) {
              document.body.removeChild(rootNode)
            }
          }
        } else if (d.$$type === 'weekly-progress-row-header') { // for table rows with $$type = 'weekly-prgress-row'
          let {node, rootNode} = d
          if ( // occlusion culling, aka only draw what's visible on screen
            // (aka "virtualization")
            !occlusionCulling ||
            d.y.pos - /*toGlobal*/adjustedScrollTop <= windowSizeY + browserUIMaxSizeBottom &&
            d.y.pos + d.sizeY.pos - /*toGlobal*/ adjustedScrollTop >= -browserUIMaxSizeTop &&
            d.x.pos <= newWindowSizeX &&
            d.x.pos + d.sizeX.pos >= 0) { // disregard shadow & sca-
              // ling for you; browserUIMaxSizeBottom and browserUIMaxSize-
              // Top are safe bigger values anyway
              node.style.width = `${d.sizeX.pos}px`
              node.style.height = `${d.sizeY.pos}px`
              node.style.transform = `translate3d(${d.x.pos}px, ${d.y.pos}px, 0) scale(${d.scale.pos})` // safari now
              // anti-aliases for hover, but then zoom in in janks on displays...
              // we can't afford fxFactor & blur for all pics;
              // too expensive for Safari & Chrome. E.g. when zoom-
              // -ing out of a photo, keep scrolling; Chrome stops
              // render on Studio Display
              node.style.filter = newFocused != null && i === newFocused - 1
                || i === newFocused || i === newFocused + 1
                ? `brightness(${d.fxFactor.pos * 100}%)
                  blur(${Math.max(0.6 - d.fxFactor.pos * 6)}px)` // blur these 3 only
                : `brightness(${d.fxFactor.pos * 100}%)` // blur of unrel-
                // ated pics is too fast during transition from/to 1D
                // mode to be seen anyway
              if (debug) node.style.outline = i === newAnchor
                ? '2px solid rgba(255, 255, 0, 0.8)' : 'none'
              if (i === newFocused) {} else {} // let it empty
              if (node.parentNode == null) {
                rootNode.children[0].appendChild(node) // if previous absent , add
                if (rootNode.parentNode == null) {
                  document.body.appendChild(rootNode)
                }
              }
          } else if(node.parentNode != null){
            node.parentNode.removeChild(node) // if previously present , remove
            if (rootNode.children[0].length === 0 && rootNode.parentNode != null) {
              document.body.removeChild(rootNode)
            }
          }
        } else { // for any other $$type
          let {node} = d
          if ( // occlusion culling, aka only draw what's visible on screen
            // (aka "virtualization")
            !occlusionCulling ||
            d.y.pos - /*toGlobal*/adjustedScrollTop <= windowSizeY + browserUIMaxSizeBottom &&
            d.y.pos + d.sizeY.pos - /*toGlobal*/ adjustedScrollTop >= -browserUIMaxSizeTop &&
            d.x.pos <= newWindowSizeX &&
            d.x.pos + d.sizeX.pos >= 0) { // disregard shadow & sca-
              // ling for you; browserUIMaxSizeBottom and browserUIMaxSize-
              // Top are safe bigger values anyway
              node.style.width = `${d.sizeX.pos}px`
              node.style.height = `${d.sizeY.pos}px`
              node.style.transform = `translate3d(${d.x.pos}px, ${d.y.pos}px, 0) scale(${d.scale.pos})` // safari now
              // anti-aliases for hover, but then zoom in in janks on displays...
              // we can't afford fxFactor & blur for all pics;
              // too expensive for Safari & Chrome. E.g. when zoom-
              // -ing out of a photo, keep scrolling; Chrome stops
              // render on Studio Display
              node.style.filter = newFocused != null && i === newFocused - 1
                || i === newFocused || i === newFocused + 1
                ? `brightness(${d.fxFactor.pos * 100}%)
                  blur(${Math.max(0.6 - d.fxFactor.pos * 6)}px)` // blur these 3 only
                : `brightness(${d.fxFactor.pos * 100}%)` // blur of unrel-
                // ated pics is too fast during transition from/to 1D
                // mode to be seen anyway
              if (debug) node.style.outline = i === newAnchor
                ? '2px solid rgba(255, 255, 0, 0.8)' : 'none'
              if (i === newFocused) {} else {} // let it empty
              if (node.parentNode == null) {
                document.body.appendChild(node) // if previous absent , add
              }
          } else if(node.parentNode != null){
            document.body.removeChild(node) // if previously present , remove
          }
        }
      }
      document.body.style.cursor = cursor
      document.body.style.overflowY = newFocused == null
        ? 'auto' : 'hidden'
      dummyPlaceholder.style.height = `${rowsTop.at(-1)}px` // Chrome
      // has race condition if scrollTo is called before setting
      // a longer dummy height

      // === step 6: update state & prepare for next time
      // if (adjustedScrollTop !== currentScrollTop) window.scrollTop({
      //   top: adjustedScrollTop }) // will trigger scrolling, thus next frame's render
      // })
      if (adjustedScrollTop !== currentScrollY) {
        // see comment about isSafari above
        (isSafari ? document.body : window).scrollTo({ top:
          adjustedScrollTop }) // will trigger scrolling, thus next frame's render
      }
      if (newFocused !== focused) {
        window.history.pushState(null, '', `${window.location.path}${window.location.search}${newFocused == null
        ? '' : '#' + data[newFocused].id}`)
      }
      events.keydown = events.click = events.mousemove = null
      animatedUntilTime = stillAnimating ?
        newAnimatedUntilTime : null
      anchor = newAnchor
      windowSizeX = newWindowSizeX
      scrollY = adjustedScrollTop

      return stillAnimating
    }

    scheduleRender()

    try {
      const params = new URLSearchParams({ listType })
      const fetchPromise = fetch(`./api/dayrecord?${params.toString()}`)
      const weeklyProgressPromise = fetch(`./api/weeklyprogress`)
//    const state = await unstable_delaySpin(fetchPromise, { delay: 100 })
      const state = 'show_the_spin'
      if (state === 'show_the_spin') {
        const item = [{id: '1', w: 768, h: 1024, $$type: 'spinner'}].map((d, i) => {
          const windowSizeY = document.documentElement.clientHeight
          const ar = d.w / d.h
          if (d.$$type === 'element') {
            const sizeX = d.w
            const sizeY = sizeX / ar + titleSizeY
            let node = document.createElement('div')
                node.className = "current-week-container"
            let header = document.createElement('header')
                header.textContent = d.title
            let contentNode = document.createElementNS("http://www.w3.org/2000/svg", "svg")
                contentNode.setAttribute('width', String(d.w))
                contentNode.setAttribute('height', String(d.h))
            node.append(header, contentNode)
            return {
              $$type: d.$$type,
              id: d.id,
              ar, // aspect ratio
              naturalSizeX: d.w,
              sizeX: spring(sizeX),
              sizeY: spring(sizeY),
              x: spring(-windowSizeX),
              y: spring(windowSizeY),
              scale: spring(1),
              fxFactor: spring(20), // for brightness and blur
              node,
            }
          } else if (d.$$type === 'spinner') {
            const sizeX = Math.min(d.w, 300)
            const sizeY = sizeX / ar
            let node = document.createElement('img')
                node.setAttribute('width', String(sizeX))
                node.setAttribute('height', String(sizeY))
                node.src = '/img/fallback.jpeg'
                node.style.position = 'absolute'
            
            let mySpring = perceptualToSpring(.4, .3)
            return {
              $$type: d.$$type,
              $$timeline: 'forward',
              id: d.id,
              ar, // aspect ratio
              naturalSizeX: d.w,
              sizeX: spring(sizeX),
              sizeY: spring(sizeY),
              x: spring((windowSizeX - sizeX) / 2),
              y: spring((windowSizeY - sizeY) / 2),
//            scale: spring(0.2, 0, 290, 14), // a little bit smaller at first
              scale: spring(0.2, 0, mySpring.k, mySpring.b), // a little bit smaller at first
              fxFactor: spring(20), // for brightness and blur
              node,
            }
          }
          throw new Error('unsupported $$type')
          
        })[0]
        data.push(item)
        await delay(2000)
        const spinner = data.shift()
        if (spinner.node.parentNode) {
          document.body.removeChild(spinner.node)
        }
        
        let dailyChartItem; {
          const windowSizeX = document.documentElement.clientWidth
          const windowSizeY = document.documentElement.clientHeight
          const { cols , boxMaxSizeX} = colsBoxMaxSizeXF(windowSizeX)
          dailyChartItem = [{id: '0', w: 700, h: 400, $$type: 'current-week-container'}].map((d, i) => {
            const ar = d.w / d.h
            const sizeX = Math.min(d.w, boxMaxSizeX)
            const sizeY = sizeX / ar + titleSizeY
            let node = document.createElement('section')
                node.className = "current-week-container"
            let header = document.createElement('header')
                header.className = "section-header"
                header.textContent = "Thành tích tuần này"
            let content = document.createElement('div')
                content.className = "content"
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg")
            content.appendChild(svg)
            node.append(header, content)
            return {
              $$type: d.$$type,
              id: d.id,
              naturalSizeX: d.w,
              ar, // aspect ratio
              sizeX: spring(sizeX),
              sizeY: spring(sizeY),
              x: spring(Math.floor(i / cols) * -windowSizeX - windowSizeX), // unfold from
              // lower left. More visible on long screens
              y: spring(windowSizeY + Math.floor(i / cols) * sizeY),
              scale: spring(1),
              fxFactor: spring(20), // for brightness and blur
              node,
            }
          })[0]
        }
        const response = await fetchPromise
        const dayRecords = await response.json()
        const resizeObserver = new ResizeObserver((entries) => {
          for (let entry of entries) {
            // We use the basic solution for drawing svg, which is simply clear
            // and redraw. Although we can optimize by other ways if we have ti-
            // me to think about the chart and contemplate other solutions
            const svg = dailyChartItem.node.childNodes[1].childNodes[0] /*SVG element*/
                  svg.setAttribute('width', String(entry.contentRect.width))
                  svg.setAttribute('height', String(entry.contentRect.height - titleSizeY))
            d3.select(svg).selectAll('*').remove() // clear previous
            currentWeekChart(
              d3.select(svg),
              dayRecords,
              {
                containerWidth: entry.contentRect.width,
                containerHeight: entry.contentRect.height - titleSizeY
              }
            )
          }
        })
        resizeObserver.observe(dailyChartItem.node)
        data.push(dailyChartItem)
        scheduleRender()
        const weeklyProgressResponse = await weeklyProgressPromise
        const weeklyProgress = await weeklyProgressResponse.json()
        {
          const windowSizeX = document.documentElement.clientWidth
          const windowSizeY = document.documentElement.clientHeight
          const { cols , boxMaxSizeX} = colsBoxMaxSizeXF(windowSizeX)
          let weeklyProgressData = []
          for (const week of weeklyProgress) {
            weeklyProgressData.push({
              tuan: formatDateRange(week.week_start, week.week_end),
              soLuongTu: week.total_net_words_a_week,
              avgNgay: week.avg_daily_net_words_a_week_so_far,
              soNgayViet: week.writing_days
            })
          }
          let rootNode; 
          if (weeklyProgressData.length) {
            rootNode = document.createElement('table') 
            rootNode.className = 'weekly-progress-table'
            let thead = document.createElement('thead')
                thead.style.position = 'absolute'
            let tbody = document.createElement('tbody')
            rootNode.append(thead, tbody)
          }

          let thead = document.createElement('thead')
              thead.style.positin = 'absolute'
          const trHeader = [{
            $$type: 'weekly-progress-row-header',
            w: '100%',
            h: 45,
            id: 'weekly-progress-header',
          }].map((d, i) => {
            const ar = null
            const sizeX = Math.min(boxMaxSizeX)
            const sizeY = 45
            let node = document.createElement('tr') 
                node.style.position = 'absolute'
                node.style.display = 'flex'
            let ths = []
            for (let i = 0; i < headers.length; i++) {
              const header = headers[i]
              const th = document.createElement('th')
                    th.textContent = header.title
                    th.style.display = 'flex'
                    th.style.width = header.width
                    ths.push(th)
            }
            node.append(...ths)
            return {
              $$type: d.$$type,
              id: d.id,
              naturalSizeX: d.w,
              ar, // aspect ratio
              sizeX: spring(sizeX),
              sizeY: spring(sizeY),
              x: spring(Math.floor(i / cols) * -windowSizeX -windowSizeX),
              y: spring(windowSizeY + Math.floor(i / cols) * sizeY),
              scale: spring(1),
              fxFactor: spring(20),
              node,
              rootNode
            }
          })[0]
          data.push(trHeader)
          weeklyProgressData = weeklyProgressData.map((d, i) => {
            return {
              id: 'weekly-progress-' + i,
              w: '100%',
              h: 45,
              $$type: 'weekly-progress-row',
            }
          }).map((d, i) => {
            if (!Number.isInteger(d.w)) {
              const ar = null
              const sizeX = Math.min(boxMaxSizeX)
              const sizeY = 45 // hardcode


              let node = document.createElement('tr')
                  node.className = "weekly-progress-row"
                  node.style.position = 'absolute'
                  node.style.display = 'flex'
              let tds = []
              for (let j = 0; j < headers.length; j++) {
                const header = headers[j]
                const td = document.createElement('td')
                      td.textContent = weeklyProgressData[i][header.key]
                      td.style.width = header.width
                      td.style.display = 'flex'
                tds.push(td)
              }
              node.append(...tds)

              return {
                $$type: d.$$type,
                id: d.id,
                naturalSizeX: d.w,
                ar, // aspect ratio
                sizeX: spring(sizeX),
                sizeY: spring(sizeY),
                x: spring(Math.floor(i / cols) * -windowSizeX -windowSizeX),
                y: spring(windowSizeY + Math.floor(i / cols) * sizeY),
                scale: spring(1),
                fxFactor: spring(20),
                node,
                rootNode
              }
            }
          })
          data.push(...weeklyProgressData)
          scheduleRender()
        }
      }
    } catch(error) {
      console.error('error', error)
    }

    

  </script>
</body>

</html>